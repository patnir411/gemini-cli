# Vulnerability Patterns Reference

Quick-reference of dangerous code patterns organized by language and vulnerability type. Use this to identify potential issues during security reviews.

## JavaScript / TypeScript

### Command Injection
```javascript
// VULNERABLE — user input in exec/spawn
const { exec } = require('child_process');
exec(`ls ${userInput}`);                        // Direct injection
spawn('sh', ['-c', `grep ${query} file.txt`]);  // Via shell flag

// SAFE — parameterized arguments
spawn('ls', [userInput]);                       // No shell interpretation
execFile('/usr/bin/grep', [query, 'file.txt']); // execFile with args array
```

### SQL Injection
```javascript
// VULNERABLE — string concatenation in queries
db.query(`SELECT * FROM users WHERE id = '${userId}'`);
db.query("SELECT * FROM users WHERE name = '" + name + "'");

// SAFE — parameterized queries
db.query('SELECT * FROM users WHERE id = $1', [userId]);
db.query('SELECT * FROM users WHERE id = ?', [userId]);
```

### Path Traversal
```javascript
// VULNERABLE — user input in file path without validation
const filePath = path.join('/uploads', req.params.filename);
fs.readFile(filePath);  // ../../etc/passwd

// SAFE — validate resolved path stays within base directory
const base = path.resolve('/uploads');
const filePath = path.resolve(base, req.params.filename);
if (!filePath.startsWith(base)) throw new Error('Invalid path');
```

### XSS
```javascript
// VULNERABLE
element.innerHTML = userInput;
document.write(userInput);
// React: <div dangerouslySetInnerHTML={{__html: userInput}} />
// Angular: bypassSecurityTrustHtml(userInput)
// Vue: <div v-html="userInput" />

// SAFE — framework default escaping handles most cases
// React: <div>{userInput}</div>  (auto-escaped)
// Angular: {{userInput}}          (auto-escaped)
// Use DOMPurify for cases requiring HTML: DOMPurify.sanitize(userInput)
```

### Prototype Pollution
```javascript
// VULNERABLE — deep merge of user-controlled object
function merge(target, source) {
  for (const key in source) {
    if (typeof source[key] === 'object') {
      merge(target[key], source[key]);  // __proto__ can be polluted
    } else {
      target[key] = source[key];
    }
  }
}
merge({}, JSON.parse(userInput));

// SAFE — check for __proto__, constructor, prototype keys
if (key === '__proto__' || key === 'constructor' || key === 'prototype') continue;
// Or use Object.create(null) as target
```

### eval / Code Execution
```javascript
// VULNERABLE
eval(userInput);
new Function(userInput)();
vm.runInNewContext(userInput);
setTimeout(userInput, 0);  // When passed a string

// SAFE — never eval user input; use JSON.parse for data
JSON.parse(userInput);
```

### Insecure Randomness
```javascript
// VULNERABLE — not cryptographically secure
const token = Math.random().toString(36);
const id = Date.now().toString();

// SAFE
const token = crypto.randomBytes(32).toString('hex');
const id = crypto.randomUUID();
```

### SSRF
```javascript
// VULNERABLE — user-controlled URL in server-side request
const response = await fetch(req.body.url);
axios.get(req.query.callback);

// SAFE — validate URL against allowlist
const url = new URL(req.body.url);
if (!ALLOWED_HOSTS.includes(url.hostname)) throw new Error('Blocked');
```

## Python

### Command Injection
```python
# VULNERABLE
os.system(f"ls {user_input}")
subprocess.call(f"grep {query} file.txt", shell=True)

# SAFE
subprocess.run(["ls", user_input])  # No shell=True
subprocess.run(["grep", query, "file.txt"])
```

### SQL Injection
```python
# VULNERABLE
cursor.execute(f"SELECT * FROM users WHERE id = '{user_id}'")
cursor.execute("SELECT * FROM users WHERE id = '%s'" % user_id)

# SAFE
cursor.execute("SELECT * FROM users WHERE id = %s", (user_id,))
# SQLAlchemy ORM handles parameterization automatically
```

### Deserialization
```python
# VULNERABLE — arbitrary code execution
import pickle
data = pickle.loads(user_input)      # RCE
import yaml
data = yaml.load(user_input)         # RCE via !!python/object

# SAFE
import json
data = json.loads(user_input)        # Data only
import yaml
data = yaml.safe_load(user_input)    # No code execution
```

### Path Traversal
```python
# VULNERABLE
filepath = os.path.join(UPLOAD_DIR, filename)
open(filepath).read()

# SAFE
filepath = os.path.realpath(os.path.join(UPLOAD_DIR, filename))
if not filepath.startswith(os.path.realpath(UPLOAD_DIR)):
    raise ValueError("Invalid path")
```

## Go

### SQL Injection
```go
// VULNERABLE
db.Query("SELECT * FROM users WHERE id = '" + id + "'")
db.Query(fmt.Sprintf("SELECT * FROM users WHERE name = '%s'", name))

// SAFE
db.Query("SELECT * FROM users WHERE id = $1", id)
```

### Command Injection
```go
// VULNERABLE
exec.Command("sh", "-c", "echo " + userInput).Run()

// SAFE
exec.Command("echo", userInput).Run()  // No shell interpretation
```

### Path Traversal
```go
// VULNERABLE
http.ServeFile(w, r, filepath.Join(baseDir, r.URL.Path))

// SAFE
cleanPath := filepath.Clean(r.URL.Path)
fullPath := filepath.Join(baseDir, cleanPath)
if !strings.HasPrefix(fullPath, baseDir) {
    http.Error(w, "Forbidden", 403)
    return
}
```

## Common Patterns Across Languages

### Hardcoded Secrets (Any Language)
```
# VULNERABLE — look for these patterns
API_KEY = "sk-abc123..."
password = "admin123"
secret = "my-jwt-secret"
token = "ghp_xxxxxxxxxxxx"
aws_secret_access_key = "AKIA..."

# SAFE — loaded from environment or secret manager
API_KEY = os.environ.get("API_KEY")
password = vault.read_secret("db/password")
```

### Weak Cryptography (Any Language)
```
# VULNERABLE algorithms for security purposes
MD5, SHA1 (for password hashing or signatures)
DES, 3DES, RC4, Blowfish
ECB mode for any block cipher
RSA with key < 2048 bits

# SAFE alternatives
bcrypt, scrypt, Argon2 (password hashing)
AES-256-GCM, ChaCha20-Poly1305 (encryption)
SHA-256, SHA-384, SHA-512 (hashing)
RSA-2048+ or Ed25519 (signatures)
```

### JWT Vulnerabilities
```
# VULNERABLE
jwt.decode(token, algorithms=["none"])        # Algorithm none attack
jwt.decode(token, verify=False)                # Signature not verified
jwt.encode(payload, "secret")                  # Weak/hardcoded secret
# Missing expiry claim (no "exp" in payload)

# SAFE
jwt.decode(token, key, algorithms=["RS256"])   # Explicit algorithm
# Verify expiry, issuer, audience claims
# Use strong, rotatable signing keys from secret management
```

### Certificate / TLS Bypass
```javascript
// VULNERABLE
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
rejectUnauthorized: false
verify: false  // Python requests

// These should NEVER appear in production code
```

## Known-Safe Patterns (Do NOT Flag)

These patterns look suspicious but are generally safe:

1. **ORM queries**: SQLAlchemy, Sequelize, Prisma, GORM — these parameterize automatically
2. **Framework template rendering**: React JSX `{variable}`, Angular `{{variable}}`, Jinja2 `{{variable}}` — auto-escaped
3. **Subprocess with array args**: `spawn('cmd', [arg1, arg2])` — no shell interpretation
4. **Environment variable reads**: `process.env.SECRET` — trusted runtime values
5. **Test fixtures**: Hardcoded values in test files are expected
6. **Hash for non-security**: MD5/SHA1 for checksums, cache keys, or deduplication is fine
7. **innerHTML with sanitized content**: `element.innerHTML = DOMPurify.sanitize(input)` — safe
